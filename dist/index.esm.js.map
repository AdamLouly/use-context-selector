{"version":3,"file":"index.esm.js","sources":["../src/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/ban-ts-ignore */\n\nimport {\n  Context,\n  FC,\n  MutableRefObject,\n  Provider,\n  createElement,\n  createContext as createContextOrig,\n  // @ts-ignore\n  createMutableSource,\n  memo,\n  useCallback,\n  useContext as useContextOrig,\n  useEffect,\n  useMemo,\n  // @ts-ignore\n  useMutableSource,\n  useRef,\n} from 'react';\n\nconst SOURCE_SYMBOL = Symbol();\nconst VALUE_PROP = 'v';\nconst LISTENERS_PROP = 'l';\n\n// @ts-ignore\ntype ContextValue<Value> = {\n  [SOURCE_SYMBOL]: any;\n};\n\nconst createProvider = <Value>(ProviderOrig: Provider<ContextValue<Value>>) => {\n  const RefProvider: FC<{ value: Value }> = ({ value, children }) => {\n    const ref = useRef({\n      [VALUE_PROP]: value,\n      [LISTENERS_PROP]: new Set<() => void>(),\n    });\n    useEffect(() => {\n      ref.current[VALUE_PROP] = value;\n      ref.current[LISTENERS_PROP].forEach((listener) => listener());\n    });\n    const contextValue = useMemo(() => ({\n      [SOURCE_SYMBOL]: createMutableSource(ref, () => ref.current[VALUE_PROP]),\n    }), []);\n    return createElement(ProviderOrig, { value: contextValue }, children);\n  };\n  return memo(RefProvider);\n};\n\nconst identity = <T>(x: T) => x;\n\n/**\n * This creates a special context for selector-enabled `useContext`.\n *\n * It doesn't pass its value but a ref of the value.\n * Unlike the original context provider, this context provider\n * expects the context value to be immutable and stable.\n *\n * @example\n * import { createContext } from 'use-context-selector';\n *\n * const PersonContext = createContext({ firstName: '', familyName: '' });\n */\nexport function createContext<Value>(defaultValue: Value) {\n  const source = createMutableSource({ current: defaultValue }, () => defaultValue);\n  const context = createContextOrig(\n    { [SOURCE_SYMBOL]: source },\n  ) as unknown as Context<Value>; // HACK typing\n  context.Provider = createProvider(\n    context.Provider as unknown as Provider<ContextValue<Value>>, // HACK typing\n  ) as Provider<Value>;\n  delete context.Consumer; // no support for Consumer\n  return context;\n}\n\nconst subscribe = (\n  ref: MutableRefObject<{ [LISTENERS_PROP]: Set<() => void> }>,\n  callback: () => void,\n) => {\n  const listeners = ref.current[LISTENERS_PROP];\n  listeners.add(callback);\n  return () => listeners.delete(callback);\n};\n\nexport function useContext<Value>(context: Context<Value>): Value;\nexport function useContext<Value, Selected>(\n  context: Context<Value>,\n  selector: (value: Value) => Selected,\n): Selected;\n\n/**\n * This hook returns context value with optional selector.\n *\n * It will only accept context created by `createContext`.\n * It will trigger re-render if only the selected value is referentially changed.\n * The selector must be stable.\n * Either define selector outside render or wrap with `useCallback`.\n *\n * The selector should return referentially equal result for same input for better performance.\n *\n * @example\n * import { useContext } from 'use-context-selector';\n *\n * const firstName = useContext(PersonContext, state => state.firstName);\n */\nexport function useContext<Value, Selected>(\n  context: Context<Value>,\n  selector: (value: Value) => Selected = identity as (value: Value) => Selected,\n) {\n  const { [SOURCE_SYMBOL]: source } = useContextOrig(\n    context,\n  ) as unknown as ContextValue<Value>; // HACK typing\n  if (process.env.NODE_ENV !== 'production') {\n    if (!source) {\n      throw new Error('This useContext requires special context for selector support');\n    }\n  }\n  const getSnapshot = useCallback(\n    (ref: MutableRefObject<{ [VALUE_PROP]: Value }>) => selector(ref.current[VALUE_PROP]),\n    [selector],\n  );\n  return useMutableSource(source, getSnapshot, subscribe);\n}\n"],"names":["SOURCE_SYMBOL","Symbol","identity","x","createContext","defaultValue","ProviderOrig","source","createMutableSource","current","context","createContextOrig","Provider","memo","value","children","ref","useRef","Set","useEffect","forEach","listener","contextValue","useMemo","createElement","Consumer","subscribe","callback","listeners","add","useContext","selector","useContextOrig","process","env","NODE_ENV","Error","getSnapshot","useCallback","useMutableSource"],"mappings":"2LAqBA,IAAMA,EAAgBC,SA2BhBC,EAAW,SAAIC,UAASA,YAcdC,EAAqBC,SAhCNC,EAiCvBC,EAASC,EAAoB,CAAEC,QAASJ,GAAgB,kBAAMA,IAC9DK,EAAUC,UACXX,GAAgBO,MAMrB,OAJAG,EAAQE,UArCqBN,EAsC3BI,EAAQE,SAvBHC,EAdmC,kBAAGC,IAAAA,MAAOC,IAAAA,SAC5CC,EAAMC,UAAM,EACFH,IADE,EAEE,IAAII,QAExBC,EAAU,WACRH,EAAIP,QAAJ,EAA0BK,EAC1BE,EAAIP,QAAJ,EAA4BW,QAAQ,SAACC,UAAaA,QAEpD,IAAMC,EAAeC,EAAQ,8BAC1BvB,GAAgBQ,EAAoBQ,EAAK,kBAAMA,EAAIP,QAAJ,OAC9C,IACJ,OAAOe,EAAclB,EAAc,CAAEQ,MAAOQ,GAAgBP,aA2BvDL,EAAQe,SACRf,EAGT,IAAMgB,EAAY,SAChBV,EACAW,GAEA,IAAMC,EAAYZ,EAAIP,QAAJ,EAElB,OADAmB,EAAUC,IAAIF,qBACDC,SAAiBD,cAwBhBG,EACdpB,EACAqB,YAAAA,IAAAA,EAAuC7B,OAEdK,EAAWyB,EAClCtB,GADOV,GAGT,GAA6B,eAAzBiC,QAAQC,IAAIC,WACT5B,EACH,UAAU6B,MAAM,iEAGpB,IAAMC,EAAcC,EAClB,SAACtB,UAAmDe,EAASf,EAAIP,QAAJ,IAC7D,CAACsB,IAEH,OAAOQ,EAAiBhC,EAAQ8B,EAAaX"}
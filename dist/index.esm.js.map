{"version":3,"file":"index.esm.js","sources":["../src/index.js"],"sourcesContent":["import React from 'react';\n\n// utils\n\nconst forcedReducer = state => state + 1;\nconst useForceUpdate = () => React.useReducer(forcedReducer, 0)[1];\n\nconst calculateChangedBits = () => 0;\n\nconst identity = x => x;\n\nconst CONTEXT_LISTENERS = Symbol('CONTEXT_LISTENERS');\n\nconst createProvider = (OrigProvider, listeners) => React.memo(({ value, children }) => {\n  // we call listeners in render intentionally.\n  // listeners are not technically pure, but\n  // otherwise we can't get benefits from concurrent mode.\n  // we make sure to work with double or more invocation of listeners.\n  listeners.forEach(listener => listener(value));\n  return React.createElement(OrigProvider, { value }, children);\n});\n\n// createContext\n\nexport const createContext = (defaultValue) => {\n  const context = React.createContext(defaultValue, calculateChangedBits);\n  const listeners = new Set();\n  // shared listeners (not ideal)\n  context[CONTEXT_LISTENERS] = listeners;\n  // hacked provider\n  context.Provider = createProvider(context.Provider, listeners);\n  // no support for consumer\n  delete context.Consumer;\n  return context;\n};\n\n// useContextSelector\n\nexport const useContextSelector = (context, selector) => {\n  const listeners = context[CONTEXT_LISTENERS];\n  if (!listeners) {\n    throw new Error('useContextSelector requires special context');\n  }\n  const forceUpdate = useForceUpdate();\n  const value = React.useContext(context);\n  const selected = selector(value);\n  const ref = React.useRef(null);\n  React.useLayoutEffect(() => {\n    ref.current = { selector, value, selected };\n  });\n  React.useLayoutEffect(() => {\n    const callback = (nextValue) => {\n      try {\n        if (ref.current.value === nextValue\n          || Object.is(ref.current.selected, ref.current.selector(nextValue))) {\n          return;\n        }\n      } catch (e) {\n        // ignored (stale props or some other reason)\n      }\n      forceUpdate();\n    };\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n    };\n  }, [forceUpdate, listeners]);\n  return selected;\n};\n\n// useContext\n\nexport const useContext = context => useContextSelector(context, identity);\n"],"names":["forcedReducer","state","calculateChangedBits","identity","x","CONTEXT_LISTENERS","Symbol","createContext","defaultValue","context","React","listeners","Set","Provider","OrigProvider","memo","value","children","forEach","listener","createElement","createProvider","Consumer","useContextSelector","selector","Error","forceUpdate","useReducer","useContext","selected","ref","useRef","useLayoutEffect","current","callback","nextValue","Object","is","e","add","delete"],"mappings":"qBAIA,IAAMA,EAAgB,SAAAC,UAASA,EAAQ,GAGjCC,EAAuB,qBAEvBC,EAAW,SAAAC,UAAKA,GAEhBC,EAAoBC,OAAO,qBAapBC,EAAgB,SAACC,GAC5B,IAAMC,EAAUC,EAAMH,cAAcC,EAAcN,GAC5CS,EAAY,IAAIC,IAOtB,OALAH,EAAQJ,GAAqBM,EAE7BF,EAAQI,SAjBa,SAACC,EAAcH,UAAcD,EAAMK,KAAK,gBAAGC,IAAAA,MAAOC,IAAAA,SAMvE,OADAN,EAAUO,QAAQ,SAAAC,UAAYA,EAASH,KAChCN,EAAMU,cAAcN,EAAc,CAAEE,MAAAA,GAASC,KAWjCI,CAAeZ,EAAQI,SAAUF,UAE7CF,EAAQa,SACRb,GAKIc,EAAqB,SAACd,EAASe,GAC1C,IAAMb,EAAYF,EAAQJ,GAC1B,IAAKM,EACH,UAAUc,MAAM,+CAElB,IAAMC,EAtCqBhB,EAAMiB,WAAW3B,EAAe,GAAG,GAuCxDgB,EAAQN,EAAMkB,WAAWnB,GACzBoB,EAAWL,EAASR,GACpBc,EAAMpB,EAAMqB,OAAO,MAqBzB,OApBArB,EAAMsB,gBAAgB,WACpBF,EAAIG,QAAU,CAAET,SAAAA,EAAUR,MAAAA,EAAOa,SAAAA,KAEnCnB,EAAMsB,gBAAgB,WACpB,IAAME,EAAW,SAACC,GAChB,IACE,GAAIL,EAAIG,QAAQjB,QAAUmB,GACrBC,OAAOC,GAAGP,EAAIG,QAAQJ,SAAUC,EAAIG,QAAQT,SAASW,IACxD,OAEF,MAAOG,IAGTZ,KAGF,OADAf,EAAU4B,IAAIL,cAEZvB,EAAU6B,OAAON,KAElB,CAACR,EAAaf,IACVkB,GAKID,EAAa,SAAAnB,UAAWc,EAAmBd,EAASN"}
{"version":3,"file":"index.umd.js","sources":["../src/index.js"],"sourcesContent":["import React from 'react';\n\n// utils\n\nconst forcedReducer = state => state + 1;\nconst useForceUpdate = () => React.useReducer(forcedReducer, 0)[1];\n\nconst calculateChangedBits = () => 0;\n\nconst identity = x => x;\n\nconst CONTEXT_LISTENERS = Symbol('CONTEXT_LISTENERS');\n\nconst createProvider = (OrigProvider, listeners) => React.memo(({ value, children }) => {\n  // we call listeners in render intentionally.\n  // listeners are not technically pure, but\n  // otherwise we can't get benefits from concurrent mode.\n  // we make sure to work with double or more invocation of listeners.\n  listeners.forEach(listener => listener(value));\n  return React.createElement(OrigProvider, { value }, children);\n});\n\n// createContext\n\nexport const createContext = (defaultValue) => {\n  const context = React.createContext(defaultValue, calculateChangedBits);\n  const listeners = new Set();\n  // shared listeners (not ideal)\n  context[CONTEXT_LISTENERS] = listeners;\n  // hacked provider\n  context.Provider = createProvider(context.Provider, listeners);\n  // no support for consumer\n  delete context.Consumer;\n  return context;\n};\n\n// useContextSelector\n\nexport const useContextSelector = (context, selector) => {\n  const listeners = context[CONTEXT_LISTENERS];\n  if (!listeners) {\n    throw new Error('useContextSelector requires special context');\n  }\n  const forceUpdate = useForceUpdate();\n  const value = React.useContext(context);\n  const selected = selector(value);\n  const ref = React.useRef(null);\n  React.useLayoutEffect(() => {\n    ref.current = { selector, value, selected };\n  });\n  React.useLayoutEffect(() => {\n    const callback = (nextValue) => {\n      try {\n        if (ref.current.value === nextValue\n          || Object.is(ref.current.selected, ref.current.selector(nextValue))) {\n          return;\n        }\n      } catch (e) {\n        // ignored (stale props or some other reason)\n      }\n      forceUpdate();\n    };\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n    };\n  }, [forceUpdate, listeners]);\n  return selected;\n};\n\n// useContext\n\nexport const useContext = context => useContextSelector(context, identity);\n"],"names":["forcedReducer","state","calculateChangedBits","identity","x","CONTEXT_LISTENERS","Symbol","useContextSelector","context","selector","listeners","Error","forceUpdate","React","useReducer","value","useContext","selected","ref","useRef","useLayoutEffect","current","callback","nextValue","Object","is","e","add","delete","defaultValue","createContext","Set","Provider","OrigProvider","memo","children","forEach","listener","createElement","createProvider","Consumer"],"mappings":"kRAIA,IAAMA,EAAgB,SAAAC,UAASA,EAAQ,GAGjCC,EAAuB,qBAEvBC,EAAW,SAAAC,UAAKA,GAEhBC,EAAoBC,OAAO,qBA2BpBC,EAAqB,SAACC,EAASC,GAC1C,IAAMC,EAAYF,EAAQH,GAC1B,IAAKK,EACH,UAAUC,MAAM,+CAElB,IAAMC,EAtCqBC,EAAMC,WAAWd,EAAe,GAAG,GAuCxDe,EAAQF,EAAMG,WAAWR,GACzBS,EAAWR,EAASM,GACpBG,EAAML,EAAMM,OAAO,MAqBzB,OApBAN,EAAMO,gBAAgB,WACpBF,EAAIG,QAAU,CAAEZ,SAAAA,EAAUM,MAAAA,EAAOE,SAAAA,KAEnCJ,EAAMO,gBAAgB,WACpB,IAAME,EAAW,SAACC,GAChB,IACE,GAAIL,EAAIG,QAAQN,QAAUQ,GACrBC,OAAOC,GAAGP,EAAIG,QAAQJ,SAAUC,EAAIG,QAAQZ,SAASc,IACxD,OAEF,MAAOG,IAGTd,KAGF,OADAF,EAAUiB,IAAIL,cAEZZ,EAAUkB,OAAON,KAElB,CAACV,EAAaF,IACVO,mBA3CoB,SAACY,GAC5B,IAAMrB,EAAUK,EAAMiB,cAAcD,EAAc3B,GAC5CQ,EAAY,IAAIqB,IAOtB,OALAvB,EAAQH,GAAqBK,EAE7BF,EAAQwB,SAjBa,SAACC,EAAcvB,UAAcG,EAAMqB,KAAK,gBAAGnB,IAAAA,MAAOoB,IAAAA,SAMvE,OADAzB,EAAU0B,QAAQ,SAAAC,UAAYA,EAAStB,KAChCF,EAAMyB,cAAcL,EAAc,CAAElB,MAAAA,GAASoB,KAWjCI,CAAe/B,EAAQwB,SAAUtB,UAE7CF,EAAQgC,SACRhC,gBAuCiB,SAAAA,UAAWD,EAAmBC,EAASL"}
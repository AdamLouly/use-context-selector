{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/ban-ts-ignore */\n\nimport {\n  Context,\n  FC,\n  MutableRefObject,\n  Provider,\n  createElement,\n  createContext as createContextOrig,\n  // @ts-ignore\n  createMutableSource,\n  memo,\n  useCallback,\n  useContext as useContextOrig,\n  useEffect,\n  useMemo,\n  // @ts-ignore\n  useMutableSource,\n  useRef,\n} from 'react';\n\nconst SOURCE_SYMBOL = Symbol();\nconst VALUE_PROP = 'v';\nconst LISTENERS_PROP = 'l';\n\n// @ts-ignore\ntype ContextValue<Value> = {\n  [SOURCE_SYMBOL]: any;\n};\n\nconst createProvider = <Value>(ProviderOrig: Provider<ContextValue<Value>>) => {\n  const RefProvider: FC<{ value: Value }> = ({ value, children }) => {\n    const ref = useRef({\n      [VALUE_PROP]: value,\n      [LISTENERS_PROP]: new Set<() => void>(),\n    });\n    useEffect(() => {\n      ref.current[VALUE_PROP] = value;\n      ref.current[LISTENERS_PROP].forEach((listener) => listener());\n    });\n    const contextValue = useMemo(() => ({\n      [SOURCE_SYMBOL]: createMutableSource(ref, () => ref.current[VALUE_PROP]),\n    }), []);\n    return createElement(ProviderOrig, { value: contextValue }, children);\n  };\n  return memo(RefProvider);\n};\n\nconst identity = <T>(x: T) => x;\n\n/**\n * This creates a special context for selector-enabled `useContext`.\n *\n * It doesn't pass its value but a ref of the value.\n * Unlike the original context provider, this context provider\n * expects the context value to be immutable and stable.\n *\n * @example\n * import { createContext } from 'use-context-selector';\n *\n * const PersonContext = createContext({ firstName: '', familyName: '' });\n */\nexport function createContext<Value>(defaultValue: Value) {\n  const source = createMutableSource({ current: defaultValue }, () => defaultValue);\n  const context = createContextOrig(\n    { [SOURCE_SYMBOL]: source },\n  ) as unknown as Context<Value>; // HACK typing\n  context.Provider = createProvider(\n    context.Provider as unknown as Provider<ContextValue<Value>>, // HACK typing\n  ) as Provider<Value>;\n  delete context.Consumer; // no support for Consumer\n  return context;\n}\n\nconst subscribe = (\n  ref: MutableRefObject<{ [LISTENERS_PROP]: Set<() => void> }>,\n  callback: () => void,\n) => {\n  const listeners = ref.current[LISTENERS_PROP];\n  listeners.add(callback);\n  return () => listeners.delete(callback);\n};\n\nexport function useContext<Value>(context: Context<Value>): Value;\nexport function useContext<Value, Selected>(\n  context: Context<Value>,\n  selector: (value: Value) => Selected,\n): Selected;\n\n/**\n * This hook returns context value with optional selector.\n *\n * It will only accept context created by `createContext`.\n * It will trigger re-render if only the selected value is referentially changed.\n * The selector must be stable.\n * Either define selector outside render or wrap with `useCallback`.\n *\n * The selector should return referentially equal result for same input for better performance.\n *\n * @example\n * import { useContext } from 'use-context-selector';\n *\n * const firstName = useContext(PersonContext, state => state.firstName);\n */\nexport function useContext<Value, Selected>(\n  context: Context<Value>,\n  selector: (value: Value) => Selected = identity as (value: Value) => Selected,\n) {\n  const { [SOURCE_SYMBOL]: source } = useContextOrig(\n    context,\n  ) as unknown as ContextValue<Value>; // HACK typing\n  if (process.env.NODE_ENV !== 'production') {\n    if (!source) {\n      throw new Error('This useContext requires special context for selector support');\n    }\n  }\n  const getSnapshot = useCallback(\n    (ref: MutableRefObject<{ [VALUE_PROP]: Value }>) => selector(ref.current[VALUE_PROP]),\n    [selector],\n  );\n  return useMutableSource(source, getSnapshot, subscribe);\n}\n"],"names":["SOURCE_SYMBOL","Symbol","identity","x","subscribe","ref","callback","listeners","current","add","defaultValue","ProviderOrig","source","createMutableSource","context","createContextOrig","Provider","memo","value","children","useRef","Set","useEffect","forEach","listener","contextValue","useMemo","createElement","Consumer","selector","useContextOrig","process","env","NODE_ENV","Error","getSnapshot","useCallback","useMutableSource"],"mappings":"uBAqBMA,EAAgBC,SA2BhBC,EAAW,SAAIC,UAASA,GA0BxBC,EAAY,SAChBC,EACAC,GAEA,IAAMC,EAAYF,EAAIG,QAAJ,EAElB,OADAD,EAAUE,IAAIH,qBACDC,SAAiBD,oCAlBKI,SAhCNC,EAiCvBC,EAASC,sBAAoB,CAAEL,QAASE,GAAgB,kBAAMA,IAC9DI,EAAUC,wBACXf,GAAgBY,MAMrB,OAJAE,EAAQE,UArCqBL,EAsC3BG,EAAQE,SAvBHC,OAdmC,kBAAGC,IAAAA,MAAOC,IAAAA,SAC5Cd,EAAMe,iBAAM,EACFF,IADE,EAEE,IAAIG,QAExBC,YAAU,WACRjB,EAAIG,QAAJ,EAA0BU,EAC1Bb,EAAIG,QAAJ,EAA4Be,QAAQ,SAACC,UAAaA,QAEpD,IAAMC,EAAeC,UAAQ,8BAC1B1B,GAAgBa,sBAAoBR,EAAK,kBAAMA,EAAIG,QAAJ,OAC9C,IACJ,OAAOmB,gBAAchB,EAAc,CAAEO,MAAOO,GAAgBN,aA2BvDL,EAAQc,SACRd,+BAkCPA,EACAe,YAAAA,IAAAA,EAAuC3B,OAEdU,EAAWkB,aAClChB,GADOd,GAGT,GAA6B,eAAzB+B,QAAQC,IAAIC,WACTrB,EACH,UAAUsB,MAAM,iEAGpB,IAAMC,EAAcC,cAClB,SAAC/B,UAAmDwB,EAASxB,EAAIG,QAAJ,IAC7D,CAACqB,IAEH,OAAOQ,mBAAiBzB,EAAQuB,EAAa/B"}
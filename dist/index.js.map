{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["import React from 'react';\n\nconst forcedReducer = state => state + 1;\n\nconst CONTEXT_LISTENERS = Symbol('C_L');\n\nconst createProvider = (OrigProvider, listeners) => React.memo(({ value, children }) => {\n  // we call listeners in render intentionally.\n  // listeners are not technically pure, but\n  // otherwise we can't get benefits from concurrent mode.\n  // we make sure to work with double or more invocation of listeners.\n  listeners.forEach((listener) => {\n    listener(value);\n  });\n  return React.createElement(OrigProvider, { value }, children);\n});\n\n// createContext\n\nexport const createContext = (defaultValue) => {\n  // make changedBits always zero\n  const context = React.createContext(defaultValue, () => 0);\n  // shared listeners (not ideal)\n  context[CONTEXT_LISTENERS] = new Set();\n  // hacked provider\n  context.Provider = createProvider(context.Provider, context[CONTEXT_LISTENERS]);\n  // no support for consumer\n  delete context.Consumer;\n  return context;\n};\n\n// useContextSelector\n\nexport const useContextSelector = (context, selector) => {\n  const listeners = context[CONTEXT_LISTENERS];\n  if (!listeners) {\n    throw new Error('useContextSelector requires special context');\n  }\n  const forceUpdate = React.useReducer(forcedReducer, 0)[1];\n  const value = React.useContext(context);\n  const selected = selector(value);\n  const ref = React.useRef(null);\n  React.useLayoutEffect(() => {\n    ref.current = {\n      f: selector, // last selector \"f\"unction\n      v: value, // last \"v\"alue\n      s: selected, // last \"s\"elected value\n    };\n  });\n  React.useLayoutEffect(() => {\n    const callback = (nextValue) => {\n      try {\n        if (ref.current.v === nextValue\n          || Object.is(ref.current.s, ref.current.f(nextValue))) {\n          return;\n        }\n      } catch (e) {\n        // ignored (stale props or some other reason)\n      }\n      forceUpdate();\n    };\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n    };\n  }, [forceUpdate, listeners]);\n  return selected;\n};\n\n// useContext\n\n// use this instead of React.useContext for consistent behavior.\n// this is not best implemented in performance,\n// but this wouldn't be used very often.\nexport const useContext = context => useContextSelector(context, x => x);\n"],"names":["forcedReducer","state","CONTEXT_LISTENERS","Symbol","useContextSelector","context","selector","listeners","Error","forceUpdate","React","useReducer","value","useContext","selected","ref","useRef","useLayoutEffect","current","f","v","s","callback","nextValue","Object","is","e","add","delete","defaultValue","OrigProvider","createContext","Set","Provider","memo","children","forEach","listener","createElement","Consumer","x"],"mappings":"4EAEMA,EAAgB,SAAAC,UAASA,EAAQ,GAEjCC,EAAoBC,OAAO,OA6BpBC,EAAqB,SAACC,EAASC,GAC1C,IAAMC,EAAYF,EAAQH,GAC1B,IAAKK,EACH,UAAUC,MAAM,+CAElB,IAAMC,EAAcC,EAAMC,WAAWX,EAAe,GAAG,GACjDY,EAAQF,EAAMG,WAAWR,GACzBS,EAAWR,EAASM,GACpBG,EAAML,EAAMM,OAAO,MAyBzB,OAxBAN,EAAMO,gBAAgB,WACpBF,EAAIG,QAAU,CACZC,EAAGb,EACHc,EAAGR,EACHS,EAAGP,KAGPJ,EAAMO,gBAAgB,WACpB,IAAMK,EAAW,SAACC,GAChB,IACE,GAAIR,EAAIG,QAAQE,IAAMG,GACjBC,OAAOC,GAAGV,EAAIG,QAAQG,EAAGN,EAAIG,QAAQC,EAAEI,IAC1C,OAEF,MAAOG,IAGTjB,KAGF,OADAF,EAAUoB,IAAIL,cAEZf,EAAUqB,OAAON,KAElB,CAACb,EAAaF,IACVO,yBA/CoB,SAACe,GAE5B,IAfsBC,EAAcvB,EAe9BF,EAAUK,EAAMqB,cAAcF,EAAc,sBAOlD,OALAxB,EAAQH,GAAqB,IAAI8B,IAEjC3B,EAAQ4B,UAnBcH,EAmBYzB,EAAQ4B,SAnBN1B,EAmBgBF,EAAQH,GAnBVQ,EAAMwB,KAAK,gBAAGtB,IAAAA,MAAOuB,IAAAA,SAQvE,OAHA5B,EAAU6B,QAAQ,SAACC,GACjBA,EAASzB,KAEJF,EAAM4B,cAAcR,EAAc,CAAElB,MAAAA,GAASuB,aAa7C9B,EAAQkC,SACRlC,sBA8CiB,SAAAA,UAAWD,EAAmBC,EAAS,SAAAmC,UAAKA"}